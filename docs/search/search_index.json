{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyST (py-semantic-taxonomy)","text":"<p>PyST is opinionated server software for creating, maintaining, and publishing SKOS/XKOS taxonomies.</p> <ul> <li>API docs, OpenAPI 3.1 JSON, OpenAPI 3.1 YAML</li> <li>GitHub repo</li> <li>Example notebook</li> </ul> <p>PyST was built and is maintained by Cauldron Solutions.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>1. Install required software</p> <ul> <li>Install and configure Postgres</li> <li>Install and configure Typesense</li> <li><code>pip install py-semantic-taxonomy</code></li> </ul> <p>2. Configure required software</p> <p>The following parameters must be either specified as environment variables, or given in the file <code>pyst-config.env</code>.</p> <p>Note</p> <p>We use <code>pydantic-settings</code> for settings management, please note their instructions on dependencies, precedence, and env file location.</p> <ul> <li><code>PyST_db_user</code> : Postgres user. Must have table and index creation rights.</li> <li><code>PyST_db_pass</code> : Postgres password for given user</li> <li><code>PyST_db_host</code> : Postgres host URL</li> <li><code>PyST_db_port</code> : Postgres port</li> <li><code>PyST_db_name</code> : Postgres database name; default is \"PyST\"</li> <li><code>PyST_auth_token</code> : Authorization header token to allow users to change data</li> <li><code>PyST_typesense_url</code> : Typesense host URL</li> <li><code>PyST_typesense_api_key</code> : Typesense API key. Must have collection creation rights.</li> <li><code>PyST_typesense_embedding_model</code> : Typesense embedding model for semantic search. Default is \"ts/all-MiniLM-L12-v2\"</li> <li><code>PyST_languages</code> : List of language codes used in the search engine and web UI. Should be a JSON string, e.g. '[\"en\", \"de\"]'.</li> </ul> <p>3. Run the server</p> <p>PyST is a FastAPI app; it can be run as any python ASGI app, e.g. with <code>uvicorn</code>:</p> <pre><code>import uvicorn\n\nuvicorn.run(\n    \"py_semantic_taxonomy.app:create_app\",\n    host=\"0.0.0.0\",\n    port=8000,\n    log_level=\"warning\",\n)\n</code></pre> <p>4. Add data</p>"},{"location":"#why-new-software","title":"Why New Software?","text":"<p>There are a number of great projects for browsing SKOS taxonomies already, including:</p> <ul> <li>showvoc</li> <li>skosmos</li> </ul> <p>JSKOS translate SKOS to JSON, and provides validation and publication capabilities. It's an amazing project with a long history, but we started with a strict requirement that data transfer would be valid JSON-LD follow SKOS and other RDF specifications.</p> <p>Our user community is comfortable with Python and relational databases, and our experiments to customize skosmos and write complicated queries in SPARQL proved to be serious barriers to barriers to productive software and vocabulary maintenance. We also wanted more flexibility on the choice of search engine.</p> <p>In <code>py_semantic_taxonomy</code> we have the following goals:</p> <ul> <li>Native and rich support for XKOS <code>Correspondence</code> and <code>ConceptAssociation</code> classes</li> <li>A predictable, consistent, and validated set of properties and property uses for SKOS and XKOS terms</li> <li>Web interface to allow for browsing</li> <li>API to allow for the complete set of CRUD operations</li> <li>API provides common graph queries without needing to learn SPARQL</li> <li>IRIs should resolve to HTML or RDF serialized resources, depending on requested media type</li> <li>Web interface supports high quality multilingual search without configuration pain</li> </ul> <p>This means that we want the following technical capabilities which are missing or more difficult than they need to be in SKOSMOS:</p> <ul> <li>A set of validation classes and functions for input data to ensure consistency in how objects are described.</li> <li>Better query performance by optimizing database structure and indices for a small set of needed edges</li> <li>Easy customization of the UI</li> <li>Pluggable search index</li> </ul> <p>To put it another way, SKOSMOS is amazing software which can handle knowledge organization systems which are based on SKOS and already exist in a graph database, but which include a lot of inconsistency and variability - PyST has a reduced feature set, but allows for easier data editing, and is much pickier about incoming data.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>The software architecture of PyST is divided into three layers: router, application, and persistence. Each has its own data transfer objects (DTO), protocols, and unit tests.</p> <p></p> <p>Each layer is independent, and can only communicate with other layers through defined protocols.</p>"},{"location":"architecture/#router","title":"Router","text":"<p>Info</p> <p>Source code for router endpoints, pydantic classes for incoming data, pydantic classes for outgoing data</p> <p>PyST uses FastAPI to define ReST API endpoints. All API endpoints consume and emit JSON-LD.</p> <p>Note</p> <p>ReST API endpoints have separate documentation.</p> <p>After using pydantic to validate incoming data, the endpoint functions create dataclasses for use in application logic, and call the appropriate application service functions.</p>"},{"location":"architecture/#application","title":"Application","text":"<p>Info</p> <p>Application graph protocol, application search protocol, DTO dataclasses</p> <p>Application functionality is implemented via service classes; we currently have two services, a graph service and a search service. Services do not persist data, but perform operations on data to either provide responses to users or prepare data for persistence.</p> <p>Application functions can call the persistence layer during function execution, or when finished. The DTO between the application and persistence layers and the same as between the router and application layers.</p>"},{"location":"architecture/#persistence","title":"Persistence","text":"<p>Info</p> <p>Persistence graph protocol, persistence search protocol, DTO dataclasses</p> <p>The persistence layer makes the actual calls to the Postgres and Typesense databases. The structure of the application and persistence protocols are quite similar; in general, business logic should go in the application layer, and the persistence layer should only be for interfacing with the databases, but in practice this distinction can get fuzzy.</p>"},{"location":"data-model/","title":"Data Model","text":""},{"location":"data-model/#overview","title":"Overview","text":"<p>The data model PyST has four fundamental classes: SKOS Concept, SKOS ConceptScheme, XKOS Correspondence, and XKOS ConceptAssociation.</p>"},{"location":"data-model/#concept-and-conceptscheme","title":"<code>Concept</code> and <code>ConceptScheme</code>","text":"<p>Each <code>Concept</code> belongs to at one <code>ConceptSchema</code>. \"Belonging\" is given with the <code>Concept.inScheme</code> property.</p> <p></p> <p>These <code>Concept</code> relationships in a given <code>ConceptScheme</code> form a graph. Each \"root\" in the graph is a \"top\" <code>Concept</code> - i.e. a <code>Concept</code> which has incoming <code>skos:broader</code> relationships, but no outgoing <code>skos:broader</code> relationships. SKOS has a potentially confusing way of encoding <code>skos:broader</code> and <code>skos:narrower</code>, because the semantic triple <code>A skos:broader B</code> means that object <code>A</code> has a relationship to a broader object <code>B</code>, not that <code>A</code> is broader than <code>B</code> (just the opposite!). SKOS uses <code>skos:topConceptOf</code> to mark these \"top\" <code>Concept</code> objects.</p> <p><code>ConceptScheme</code> graphs are directed acyclic graphs. They are directed because their edges (<code>A skos:broader B</code>) have direction and are not symmetric; they are acyclic because of their nature in describing taxonomies which always get broader as one goes \"up\" the hierarchy towards the \"top\" <code>Concepts</code>.</p> <p>A PyST deployment will normally have many <code>ConceptScheme</code> graphs, and these individual graphs can be linked in several ways. <code>Concepts</code> can belong to more than one <code>ConceptScheme</code> - for example, we will be using the Combined Nomenclature or CN as a base classification for products, but supplementing it with more specific graphs (like the Open Energy Ontology or OEO) when more detail is needed. As is discussed below, we can't have hierarchical relationships which cross <code>ConceptScheme</code> graphs, but if introduce a third common <code>ConceptScheme</code> we can create hierarchies which span input <code>ConceptSchemes</code>:</p> <p></p>"},{"location":"data-model/#conceptassociation-and-correspondence","title":"<code>ConceptAssociation</code> and <code>Correspondence</code>","text":"<p><code>ConceptAssociation</code> and <code>Correspondence</code> are another fundamental type of relationship we can put in the graph. Just like the SKOS term <code>ConceptScheme</code> serves as an organizational unit for <code>Concepts</code>, the XKOS term <code>Correspondence</code> is an organizational unit for these <code>ConceptAssociations</code>.</p> <p></p> <p>While the XKOS standard does allow M-to-N mappings (i.e. multiple concepts in one concept scheme mapping to multiple concepts in another concept scheme), we require that each concept in the source concept scheme be mapped separately to the appropriate target concepts.</p> <p>One frustration of the current XKOS standard is that no additional properties for describing the qualities of <code>ConceptAssociation</code> are offered: \"In this version, XKOS does not define any properties or sub-classes for <code>xkos:Correspondence</code> and <code>xkos:ConceptAssociation</code> in order to model these different types of correspondences. This may be added in a future version.\" (Source). This means that if we want to indicate the quality of a mapping between two <code>Concepts</code> in addition to their membership in a <code>ConceptAssociation</code>, we would need to create a separate associative relationship. Note that this means that these associative properties will not be linked directly to the <code>ConceptAssociation</code> instance.</p> <p>We don't assume reciprocity for <code>ConceptAssociations</code> - i.e. if source <code>A</code> is mapped to target <code>B</code>, it doesn't mean that source <code>B</code> is mapped to target <code>A</code>.</p>"},{"location":"data-model/#conditional-conceptassociation","title":"Conditional <code>ConceptAssociation</code>","text":"<p>In certain cases a <code>Concept</code> in scheme <code>A</code> can correspond to a <code>Concept</code> in scheme <code>B</code>, but only when it is paired with another <code>Concept</code> from scheme <code>C</code>. For example, <code>A:electricity</code> is equivalent to <code>B:renewable_electricity</code> when it is produced by <code>C:wind_turbine</code>.</p> <p>We will slightly abuse the <code>ConceptAssociation</code> class to meet this modelling need by allowing <code>ConceptAssociation</code> to link three <code>ConceptSchemes</code>. In this case, each <code>ConceptAssociation</code> should have two <code>sourceConcepts</code> and one <code>targetConcept</code>.</p> <p></p> <p>Note that conditionality here is implicit - it is not given by a specific property but only because there are two <code>sourceConcepts</code>.</p> <p>Warning</p> <p>Our usage here differs from XKOS best practices. Please reach out to <code>info@cauldron.ch</code> if you have alternative ideas on how to implement conditional association.</p>"},{"location":"data-model/#hierarchical-and-associative-concept-relationships","title":"Hierarchical and associative <code>Concept</code> relationships","text":"<p>A hierarchical relationship is a <code>skos:broader</code> or <code>skos:narrower</code> (or <code>skos:broaderTransitive</code>/<code>skos:narrowerTransitive</code>) relationship within a <code>ConceptScheme</code> taxonomy. An associative relationship crosses from one <code>ConceptScheme</code> to another, or from one \"branch\" of a <code>ConceptScheme</code> to another, and uses the SKOS properties <code>skos:related</code>, <code>skos:exactMatch</code>, <code>skos:closeMatch</code>, <code>skos:relatedMatch</code>, <code>skos:broadMatch</code>, and <code>skos:narrowMatch</code>.</p> <p>You shouldn't specify associative relationships for two concepts which are related through a transitive chain of <code>skos:broader</code> relationships. PyST does some basic checks to enforce this distinction, though because we allow <code>Concepts</code> to belong to more than one <code>ConceptScheme</code> it's difficult to do comprehensive checks.</p>"},{"location":"data-model/#general-constraints-and-assumptions","title":"General constraints and assumptions","text":"<p>PyST is a opinionated software - it puts additional constraints on the SKOS and XKOS ontologies to ensure consistency and usability.</p> <p>PyST uses the open-world assumption in its logic. The open-world assumption is that there are facts which are true but are not stated in our system. So, for example, just because our system doesn't have a <code>skos:broader</code> relationship or a <code>ConceptAssociation</code> between two <code>Concepts</code> doesn't mean that those links don't exist - just that we don't know abot them yet.</p> <p>There are a few general constraints which are applied to all classes:</p> <ul> <li>We assume that <code>Concepts</code> within a <code>ConceptScheme</code> have a strictly transitive hierarchy - e.g. if <code>A</code> is broader than <code>B</code>, and <code>B</code> is broader than <code>C</code>, then <code>A</code> is always broader than <code>C</code>. There is therefore no need to specify <code>broaderTransitive</code> or <code>narrowerTransitive</code>, as these are implicit in the taxonomy graph. Similarly, as <code>broader</code> and <code>narrower</code> are reciprocal, API inputs should only specify <code>broader</code> relationships - giving both sides of a <code>broader</code>/<code>narrower</code> relationship will raise a <code>DuplicateRelationship</code> error.</li> <li>Incoming data must be JSON-LD in the JSON-LD 1.1 expanded form. Expanded form means that there is no <code>@context</code> section of the JSON-LD document.</li> </ul> <p>Note</p> <p>If you are using rdflib, you may run into trouble with nested namespaces. Specifying <code>version=1.1</code> during parsing (i.e. <code>rdflib.Graph().parse(..., version=\"1.1\")</code> or reading and re-serializing with PyLD should work.</p> <ul> <li>All string literals must specify a language and can specify a direction. In other words, <code>\"ceci n'est pas une pipe\"</code> is not allowed - you must instead give <code>{\"@language\": \"fr\", \"@value\": \"ceci n'est pas une pipe\"}</code>.</li> <li>Only one <code>skos:prefLabel</code> and one <code>skos:definition</code> per language code are allowed.</li> <li>If specifying a version using <code>owl:versionInfo</code>, only one value is allowed.</li> </ul>"},{"location":"data-model/#tracking-changes","title":"Tracking changes","text":"<p>We follow the SKOS Primer guidance on documentary notes for the fields <code>skos:changeNote</code>, <code>skos:editorialNote</code>, and <code>skos:historyNote</code>:</p> <ul> <li><code>skos:changeNote</code> documents fine-grained changes to a concept, for the purposes of administration and maintenance, e.g. \"Moved from under 'fruits' to under 'vegetables' by Horace Gray\"</li> <li><code>skos:editorialNote</code> supplies information that is an aid to administrative housekeeping, such as reminders of editorial work still to be done, e.g. \"Check spelling with John Doe\"</li> <li><code>skos:historyNote</code> describes significant changes to the meaning or the form of a concept, e.g. \"estab. 1975; heading was: Cruelty to children [1952-1975]\"</li> </ul> <p>All three of these notes are required to be RDF resources instead of string literals, and in addition to their values (<code>rdf:value</code>), they must also include a creator (<code>dcterms:creator</code>) and an issuance timestamp (<code>dcterms:issued</code>). Here is an example:</p> <pre><code>{\n    \"http://purl.org/dc/terms/creator\": [{\"@id\": \"http://example.com/john.doe\"}],\n    \"http://purl.org/dc/terms/issued\": [\n        {\"@type\": \"http://www.w3.org/2001/XMLSchema#date\", \"@value\": \"1999-01-23\"}\n    ],\n    \"http://www.w3.org/1999/02/22-rdf-syntax-ns#value\": [\n        {\"@language\": \"en\", \"@value\": \"Moved from under 'fruits' to under 'vegetables'\"}\n    ],\n}\n</code></pre>"},{"location":"data-model/#publication-status","title":"Publication status","text":"<p>SKOS and XKOS don't provide constructs for tracking status. We have chosen to use a subset of the BIBO ontology, and support three different status options:</p> <ul> <li>draft (<code>http://purl.org/ontology/bibo/status/draft</code>)</li> <li>accepted (<code>http://purl.org/ontology/bibo/status/accepted</code>)</li> <li>rejected (<code>http://purl.org/ontology/bibo/status/rejected</code>)</li> </ul> <p>The predicate verb is <code>http://purl.org/ontology/bibo/status</code>.</p>"},{"location":"data-model/#conceptscheme","title":"<code>ConceptScheme</code>","text":"<p>We impose the following additional constraints on <code>ConceptScheme</code> objects:</p> <ul> <li>At least one <code>skos:prefLabel</code> and one <code>skos:definition</code> are required</li> <li><code>bibo:status</code>, <code>dcterms:created</code>, <code>owl:versionInfo</code> are required</li> <li>Exactly one <code>owl:versionInfo</code> value is specified</li> <li>At least one definition (<code>skos:definition</code>) is given</li> <li>Instead of supplying a (very long) list of <code>skos:hasTopConcept</code> concept references, please instead specify <code>skos:topConceptOf</code> on the <code>Concept</code> instances.</li> </ul> <p>Here is a minimal <code>ConceptScheme</code> example:</p> <pre><code>{\n  \"@id\": \"http://data.europa.eu/xsp/cn2024/cn2024\",\n  \"@type\": [\n    \"http://www.w3.org/2004/02/skos/core#ConceptScheme\"\n  ],\n  \"http://purl.org/dc/terms/created\": [\n    {\n      \"@type\": \"http://www.w3.org/2001/XMLSchema#dateTime\",\n      \"@value\": \"2023-10-11T13:59:56\"\n    }\n  ],\n  \"http://purl.org/dc/terms/creator\": [\n    {\n      \"@id\": \"http://publications.europa.eu/resource/authority/corporate-body/ESTAT\"\n    },\n    {\n      \"@id\": \"http://publications.europa.eu/resource/authority/corporate-body/TAXUD\"\n    }\n  ],\n  \"http://www.w3.org/2002/07/owl#versionInfo\": [\n    {\n      \"@value\": \"2024\"\n    }\n  ],\n  \"http://purl.org/ontology/bibo/status\": [\n    {\n      \"@id\": \"http://purl.org/ontology/bibo/status/accepted\"\n    }\n  ],\n  \"http://www.w3.org/2004/02/skos/core#prefLabel\": [\n    {\n      \"@value\": \"Combined Nomenclature, 2024 (CN 2024)\",\n      \"@language\": \"en\"\n    },\n    {\n      \"@value\": \"Nomenclatura Combinada, 2024 (NC 2024)\",\n      \"@language\": \"pt\"\n    }\n  ],\n  \"http://www.w3.org/2004/02/skos/core#definition\": [\n    {\n      \"@value\": \"The main classification for the European ITGS (International trade in goods statistics)  is the Combined Nomenclature (CN). This is the primary nomenclature as it is the one used by the EU Member States to collect detailed data on their trading of goods since 1988. Before the introduction of the CN, ITGS were based on a product classification called NIMEXE.  The CN is based on the Harmonised Commodity Description and Coding System (managed by the World Customs Organisation (WCO). The Harmonised System (HS) is an international classification at two, four and six-digit level which classifies goods according to their nature. It was introduced in 1988 and, since then, was revised six times: in 1996, 2002, 2007, 2012, 2017 and 2022. The CN corresponds to the HS plus a further breakdown at eight-digit level defined to meet EU needs. The CN is revised annually and, as a Council Regulation, is binding on the Member States.\",\n      \"@language\": \"en\"\n    }\n  ],\n  \"http://www.w3.org/2004/02/skos/core#notation\": [\n    {\n      \"@value\": \"CN 2024\",\n      \"@type\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral\"\n    }\n  ]\n}\n</code></pre>"},{"location":"data-model/#concept","title":"<code>Concept</code>","text":"<p>We impose the following additional constraints on <code>Concept</code> objects:</p> <ul> <li>At least one <code>skos:prefLabel</code> is required</li> <li>A <code>bibo:status</code> is required</li> <li>Each <code>Concept</code> must be in at least one known (i.e. in our database already) <code>ConceptScheme</code>. <code>Concepts</code> can belong to more than one <code>ConceptScheme</code>.</li> <li><code>Concepts</code> can be in a relationship with itself. Insert your own joke here.</li> <li>The use of <code>skos:note</code> is discouraged (but not prohibited) in favor of the specific <code>skos:note</code> subclasses: <code>skos:scopeNote</code>, <code>skos:definition</code>, <code>skos:example</code>, <code>skos:historyNote</code>, <code>skos:editorialNote</code>, and <code>skos:changeNote</code>. Their use should follow the intended use as documented in the SKOS Primer.</li> <li><code>skos:notation</code> must be a typed literal - not a string literal - and not include a <code>@language</code> tag. The default datatype should be <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral</code>.</li> <li>We break from SKOS guidance to prohibit <code>skos:notation</code> having the same value as <code>skos:prefLabel</code>. A notation is 'a string of characters such as \"T58.5\" or \"303.4833\" used to uniquely identify a concept within the scope of a given concept scheme'; this definition is inconsistent with lexical labels like <code>skos:prefLabel</code>, which are human-readable and in a natural language. In our system, <code>skos:prefLabel</code> is required but <code>skos:notation</code> is optional.</li> </ul> <p>Here is a minimal <code>Concept</code> example:</p> <pre><code>{\n  \"@id\": \"http://data.europa.eu/xsp/cn2024/010011000090\",\n  \"@type\": [\"http://www.w3.org/2004/02/skos/core#Concept\"],\n  \"http://www.w3.org/2004/02/skos/core#inScheme\": [\n    {\"@id\": \"http://data.europa.eu/xsp/cn2024/cn2024\"}\n  ],\n  \"http://purl.org/ontology/bibo/status\": [\n    {\"@id\": \"http://purl.org/ontology/bibo/status/accepted\"}\n  ],\n  \"http://www.w3.org/2004/02/skos/core#prefLabel\": [\n    {\n      \"@value\": \"SECTION I - LIVE ANIMALS; ANIMAL PRODUCTS\",\n      \"@language\": \"en\"\n    },\n    {\n      \"@value\": \"SEC\\u00c7\\u00c3O I - ANIMAIS VIVOS E PRODUTOS DO REINO ANIMAL\",\n      \"@language\": \"pt\"\n    }\n  ],\n  \"http://www.w3.org/2004/02/skos/core#notation\": [\n    {\n      \"@value\": \"I\",\n      \"@type\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral\"\n    }\n  ],\n  \"http://www.w3.org/2004/02/skos/core#definition\": [\n    {\n      \"@language\": \"en\",\n      \"@value\": \"LIVE ANIMALS; ANIMAL PRODUCTS\"\n    }\n  ],\n  \"http://www.w3.org/2004/02/skos/core#topConceptOf\": [\n    {\"@id\": \"http://data.europa.eu/xsp/cn2024/cn2024\"}\n  ]\n}\n</code></pre>"},{"location":"data-model/#correspondence","title":"Correspondence","text":"<p>The XKOS ontology provides the Correspondence class definition, which we use follow the XKOS best practice guide. A <code>Correspondence</code> instance is very similar to a <code>ConceptScheme</code> - it provides metadata for a collection of child nodes.</p> <p>In addition to our generic addition restrictions, <code>Correspondence</code> must have:</p> <ul> <li>Exactly one <code>http://purl.org/dc/terms/issued</code> value.</li> </ul> <p>Here is an example of a valid <code>Correspondence</code> in JSON-LD:</p> <pre><code>{\n  \"@id\": \"http://data.europa.eu/xsp/cn2024/CN2024_CN2023\",\n  \"@type\": [\"http://rdf-vocabulary.ddialliance.org/xkos#Correspondence\"],\n  \"http://rdf-vocabulary.ddialliance.org/xkos#compares\": [\n      {\"@id\": \"http://data.europa.eu/xsp/cn2024\"}\n      {\"@id\": \"http://data.europa.eu/xsp/cn2023\"}\n  ],\n  \"http://www.w3.org/2004/02/skos/core#definition\": [\n    {\n      \"@value\": \"This table is indicative and has no legal value.\",\n      \"@language\": \"en\"\n    }\n  ],\n  \"http://www.w3.org/2004/02/skos/core#prefLabel\": [\n    {\n      \"@value\": \"Transposition between CN 2024 and CN 2023\",\n      \"@language\": \"en\"\n    }\n  ],\n  \"http://purl.org/dc/terms/issued\": [\n    {\n      \"@type\": \"http://www.w3.org/2001/XMLSchema#dateTime\",\n      \"@value\": \"2024-07-02T08:41:55\"\n    }\n  ]\n}\n</code></pre>"},{"location":"data-model/#conceptassociation","title":"<code>ConceptAssociation</code>","text":"<p>We don't impose any additional restrictions outside of the XKOS specification on <code>ConceptAssociation</code>.</p> <p>XKOS doesn't provide any additional properties <code>ConceptAssociations</code>, but we can use <code>qudt:conversionMultiplier</code> to give 1-N partitioning or allocation constants. Though this isn't the intention of this predicate in QUDT, it domain and range fit, and allocation is similar enough to unit conversion. Please feel free to suggest an alternative if you find something which fits better!</p> <p>Here is an example of a valid 1-to-N <code>ConceptAssociation</code> in JSON-LD:</p> <pre><code>{\n  \"@id\": \"http://data.europa.eu/xsp/cn2024/CN2024_CN2023_010239100080\",\n  \"@type\": [\"http://rdf-vocabulary.ddialliance.org/xkos#ConceptAssociation\"],\n  \"http://rdf-vocabulary.ddialliance.org/xkos#sourceConcept\": [\n      {\"@id\": \"http://data.europa.eu/xsp/cn2024/010239000080\"}\n  ],\n  \"http://rdf-vocabulary.ddialliance.org/xkos#targetConcept\": [\n    {\n      \"@id\": \"http://data.europa.eu/xsp/cn2024/010239900080\",\n      \"http://qudt.org/3.0.0/schema/qudt/conversionMultiplier\": 0.75\n    },\n    {\n      \"@id\": \"http://data.europa.eu/xsp/cn2024/010239100080\",\n      \"http://qudt.org/3.0.0/schema/qudt/conversionMultiplier\": 0.25\n    }\n  ]\n}\n</code></pre> <p>And here is a conditional <code>ConceptAssociation</code>:</p> <pre><code>{\n  \"@id\": \"http://example.com/conditional\",\n  \"@type\": [\"http://rdf-vocabulary.ddialliance.org/xkos#ConceptAssociation\"],\n  \"http://rdf-vocabulary.ddialliance.org/xkos#sourceConcept\": [\n      {\"@id\": \"http://example.com/A/electricity\"},\n      {\"@id\": \"http://example.com/C/wind_turbine\"}\n  ],\n  \"http://rdf-vocabulary.ddialliance.org/xkos#targetConcept\": [\n      {\"@id\": \"http://example.com/B/renewable_electricity\"}\n  ]\n}\n</code></pre>"},{"location":"development/","title":"Development and testing","text":""},{"location":"development/#asynchronous-code","title":"Asynchronous code","text":"<p>All three layers of PyST are asynchronous; most functions and methods user <code>async</code> and must be called with <code>await</code>. Developing in this style can be challenging at first; see the tests for patterns which you can follow if you need help.</p>"},{"location":"development/#prerequisites","title":"Prerequisites","text":"<p>Use <code>pip install \"py-semantic-taxonomy[dev]\"</code> to get everything needed for development and testing.</p>"},{"location":"development/#containers-for-postgres-and-typesense","title":"Containers for Postgres and Typesense","text":"<p>Development and testing require Docker via testcontainers. On MacOS you will need a recent version of Docker Desktop - the alternatives don't seem to work.</p> <p>The <code>scripts</code> directory has two scripts for running Postgres and Typesense containers:</p> <ul> <li>start_typesense_container.py</li> <li>start-postgres-container.py</li> </ul> <p>If you run those scripts, you will get instructions on how to set the environment variable values needed to run the development server:</p> <pre><code>python src/py_semantic_taxonomy/app.py\n</code></pre>"},{"location":"development/#testing","title":"Testing","text":"<p>When adding new functionality, it's important to write unit tests for each layer effected, as well as integration tests. Unit tests should mock the other layers - see the conftest.py file for test mocks and fixture data.</p> <p></p>"},{"location":"development/#linting","title":"Linting","text":"<pre><code>isort --profile=black tests/ &amp;&amp; black tests/ &amp;&amp; \\\nisort --profile=black src/ &amp;&amp; black src/\n</code></pre>"}]}